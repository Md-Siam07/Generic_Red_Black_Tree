#pragma once
#include<stdexcept>
#include <iostream>
#include<vector>
#include<algorithm>
using std::cout;
using std::endl;
using namespace std;
// DO NOT EDIT THIS FILE IN ANY WAY

// NodeT class for Linked List
template <class X>

class NodeT
{
public:
    X data;
    //NodeT* previous;
    NodeT<X>* left;
    NodeT<X>* right;
    NodeT<X>* parent;
    bool isBlack;
    NodeT()
    {
        //data = new X;
        left = nullptr;
        right = nullptr;
        parent = nullptr;
        isBlack = false;
    }
    NodeT(X val) : data(val), left(nullptr), right(nullptr), parent(nullptr), isBlack(false) {};
    //NodeT(): next(nullptr) {};
};

template <class X>
class RedBlackTree
{
public:
    NodeT<X>* root;
    // Constructors, destructor and overloaded op=
    RedBlackTree(){root=nullptr;};
    RedBlackTree(const RedBlackTree & rbt)
    {
        n = rbt.n;

        root = new NodeT<X>;
        *root = *(rbt.root);
        //this->front = dq->front;
        //this->back = dq->back;
    };
    ~RedBlackTree();

    // Mutators
    // PARAM: val = value to be inserted
    // POST: inserts val at the front of the RedBlackTree
    bool insert(X val);
    // PARAM: val = value to be inserted
    // POST: inserts val at the back of the RedBlackTree
    bool remove(X val);
    bool search(X val) const;
    vector<X> search(X low, X high) const;
    X closestLess(X val);
    X closestGreater(X val);
    vector<X> values();

    template<class T>
    friend NodeT<T>* JWMEgetRoot(const RedBlackTree<T> &rbt);
    // POST: removes NodeT at the front of the RedBlackTree and returns its data
    //int remove_front();
    // POST: removes NodeT at the back of the RedBlackTree and returns its data
    //int remove_back();

    // POST: returns the number values stored in the RedBlackTree
    int size() const;
    // POST: returns T iff RedBlackTree is empty

    RedBlackTree<X> & operator=(const RedBlackTree<X> & dq);



private:
    int n=0;


    // PARAM: dq = RedBlackTree to be copied
    // POST: calling object is made a copy of dq
    void copyRedBlackTree(const RedBlackTree & dq);
    //void copyitems(RedBlackTree<X> rbt);
    NodeT<X> *searchNode(X n) {
    NodeT<X> *temp = root;
    while (temp != NULL) {
      if (n < temp->data) {
        if (temp->left == NULL)
          break;
        else
          temp = temp->left;
      } else if (n == temp->data) {
        break;
      } else {
        if (temp->right == NULL)
          break;
        else
          temp = temp->right;
      }
    }

    return temp;
  }

    void leftRotate(NodeT<X> *x)
    {
        // new parent will be NodeT's right child
        NodeT<X> *nParent = x->right;

        // update root if current NodeT is root
        if (x == root)
            root = nParent;

        if(x->parent!=NULL){
            if(x==x->parent->left)
                x->parent->left=nParent;
            else
                x->parent->right=nParent;
        }
        nParent->parent=x->parent;
        x->parent=nParent;

        // connect x with new parent's left element
        x->right = nParent->left;
        // connect new parent's left element with NodeT
        // if it is not null
        if (nParent->left != NULL)
            nParent->left->parent = x;

        // connect new parent with x
        nParent->left = x;
    }

    void helper(NodeT<X> *root, vector<X> &val){
        val.push_back(root->data);
        if(root->left!=nullptr)
            helper(root->left, val);
        if(root->right!=nullptr)
            helper(root->right,val);
    }

    void helperofclosestless(NodeT<X> *root, X x, X &val){
        //cout<< "root->data: "<< root->data<< " x: "<< x<< " val: "<<val<<endl;
        if(x==val){
            if(root->data<val){
                val=root->data;
            }
        }
        else if(root->data>val && root->data<=x){
            val = root->data;
        }
        if(root->left!=nullptr)
            helperofclosestless(root->left, x, val);
        if(root->right!=nullptr)
            helperofclosestless(root->right, x, val);
    }

    void helperofclosestgreater(NodeT<X> *root, X x, X &val){
        //cout<< "root->data: "<< root->data<< " x: "<< x<< " val: "<<val<<endl;
        if(x==val){
            if(root->data>val){
                val=root->data;
            }
        }
        else if(root->data<val && root->data>=x){
            val = root->data;
        }
        if(root->left!=nullptr)
            helperofclosestgreater(root->left, x, val);
        if(root->right!=nullptr)
            helperofclosestgreater(root->right, x, val);
    }

    void copyhelper(NodeT<X> *x, NodeT<X> *newParent ,NodeT<X> *y)
    {
        /*y=x;
        cout<< y->data<< " "<< x->data<<endl;
        if(x->left!=nullptr)
        {
            copyhelper(y->left, x->left);
        }
        if(x->right!=nullptr){
            copyhelper(y->right, x->right);
        }*/
        if(y==nullptr)
            x=nullptr;
        else{
            x = new NodeT<X>();
            x->data = y->data;
            x->left = y->left;
            x->right = y->right;
            x->parent = newParent;

            copyhelper(x->left, x, y->left);
            copyhelper(x->right, x, y->right);
        }
    }


    void rightRotate(NodeT<X> *x)
    {
        // new parent will be NodeT's left child
        NodeT<X> *nParent = x->left;

        // update root if current NodeT is root
        if (x == root)
            root = nParent;

        if(x->parent!=NULL){
            if(x==x->parent->left)
                x->parent->left=nParent;
            else
                x->parent->right=nParent;
        }
        nParent->parent=x->parent;
        x->parent=nParent;

        // connect x with new parent's right element
        x->left = nParent->right;
        // connect new parent's right element with NodeT
        // if it is not null
        if (nParent->right != NULL)
            nParent->right->parent = x;

        // connect new parent with x
        nParent->right = x;
    }

    void swapColors(NodeT<X> *x1, NodeT<X> *x2)
    {
        bool temp;
        temp = x1->isBlack;
        x1->isBlack = x2->isBlack;
        x2->isBlack = temp;
    }

    void swapValues(NodeT<X> *u, NodeT<X> *v)
    {
        X temp;
        temp = u->data;
        u->data = v->data;
        v->data = temp;
    }

    // fix red red at given NodeT
    void fixRedRed(NodeT<X> *x)
    {
        // if x is root color it black and return
        if (x == root)
        {
            x->isBlack = true;
            return;
        }

        // initialize parent, grandparent, uncle
        NodeT<X> *parent = x->parent, *grandparent = parent->parent,
              *uncle;
        if(parent==nullptr or grandparent==nullptr) uncle=nullptr;
        else if(parent==parent->parent->left) uncle= parent->parent->right;
        else uncle = parent->parent->left;

        if (parent->isBlack != true)
        {
            if (uncle != NULL && uncle->isBlack == false)
            {
                // uncle red, perform recoloring and recurse
                parent->isBlack = true;
                uncle->isBlack = true;
                grandparent->isBlack = false;
                fixRedRed(grandparent);
            }
            else
            {

                // Else perform LR, LL, RL, RR
                if (parent == parent->parent->left)
                {
                    if (x == x->parent->left)
                    {
                        // for left right
                        swapColors(parent, grandparent);
                    }
                    else
                    {
                        leftRotate(parent);
                        swapColors(x, grandparent);
                    }
                    // for left left and left right
                    rightRotate(grandparent);
                }
                else
                {
                    if (x == x->parent->left)
                    {
                        // for right left
                        rightRotate(parent);
                        swapColors(x, grandparent);
                    }
                    else
                    {
                        swapColors(parent, grandparent);
                    }

                    // for right right and right left
                    leftRotate(grandparent);
                }
            }
        }
    }

    // find NodeT that do not have a left child
    // in the subtree of the given NodeT
    NodeT<X> *successor(NodeT<X> *x)
    {
        NodeT<X> *temp = x;

        while (temp->left != NULL)
            temp = temp->left;

        return temp;
    }

    void helperremove(NodeT<X> *root)
    {
        if(root==nullptr) return;
        if(root->left!=nullptr){
            helperremove(root->left);
        }
        if(root->right!=nullptr){
            helperremove(root->right);
        }
        delete root;
    }
    // find NodeT that replaces a deleted NodeT in BST
    NodeT<X> *BSTreplace(NodeT<X> *x)
    {
        // when NodeT have 2 children
        if (x->left != NULL and x->right != NULL)
            return successor(x->right);

        // when leaf
        if (x->left == NULL and x->right == NULL)
            return NULL;

        // when single child
        if (x->left != NULL)
            return x->left;
        else
            return x->right;
    }

    // deletes the given NodeT
    void deleteNode(NodeT<X> *v)
    {
        NodeT<X> *u = BSTreplace(v);

        // True when u and v are both black
        bool uvBlack = ((u == NULL or u->isBlack == true) and (v->isBlack == true));
        NodeT<X> *parent = v->parent;

        if (u == NULL)
        {
            // u is NULL therefore v is leaf
            if (v == root)
            {
                // v is root, making root null
                root = NULL;
            }
            else
            {
                if (uvBlack)
                {
                    // u and v both black
                    // v is leaf, fix double black at v
                    fixDoubleBlack(v);
                }
                else
                {
                    // u or v is red
                    NodeT<X> *sibling;
                    if(v->parent==nullptr) sibling=nullptr;
                    else if(v == v->parent->left) sibling = v->parent->right;
                    else sibling = v->parent->left;
                    if (sibling != NULL)
                        // sibling is not null, make it red"
                        sibling->isBlack = true;
                }

                // delete v from the tree
                if (v == v->parent->left)
                {
                    parent->left = NULL;
                }
                else
                {
                    parent->right = NULL;
                }
            }
            delete v;
            return;
        }

        if (v->left == NULL or v->right == NULL)
        {
            // v has 1 child
            if (v == root)
            {
                // v is root, assign the value of u to v, and delete u
                v->data = u->data;
                v->left = v->right = NULL;
                delete u;
            }
            else
            {
                // Detach v from tree and move u up
                if (v == v->parent->left)
                {
                    parent->left = u;
                }
                else
                {
                    parent->right = u;
                }
                delete v;
                u->parent = parent;
                if (uvBlack)
                {
                    // u and v both black, fix double black at u
                    fixDoubleBlack(u);
                }
                else
                {
                    // u or v red, color u black
                    u->isBlack = true;
                }
            }
            return;
        }

        // v has 2 children, swap values with successor and recurse
        swapValues(u, v);
        deleteNode(u);
    }

    void fixDoubleBlack(NodeT<X> *x)
    {//https://us04web.zoom.us/j/77643122127?pwd=SnJWV2h1NHg4dC8xa1EzQnFVSG42QT09
        if (x == root)
            // Reached root
            return;

        NodeT<X> *sibling;
        if(x->parent==nullptr) sibling=nullptr;
        else if(x == x->parent->left) sibling = x->parent->right;
        else sibling = x->parent->left;
        NodeT<X> *parent = x->parent;
        if (sibling == NULL)
        {
            // No sibiling, double black pushed up
            fixDoubleBlack(parent);
        }
        else
        {
            if (sibling->isBlack == false)
            {
                // Sibling red
                parent->isBlack = false;
                sibling->isBlack = true;
                if (sibling == sibling->parent->left)
                {
                    // left case
                    rightRotate(parent);
                }
                else
                {
                    // right case
                    leftRotate(parent);
                }
                fixDoubleBlack(x);
            }
            else
            {
                // Sibling black
                bool hasRedChild;
                hasRedChild = (sibling->left != NULL and sibling->left->isBlack == false) or
           (sibling->right != NULL and sibling->right->isBlack == false);
                if (hasRedChild)
                {
                    // at least 1 red children
                    if (sibling->left != NULL and sibling->left->isBlack == false)
                    {
                        if (sibling == sibling->parent->left)
                        {
                            // left left
                            sibling->left->isBlack = sibling->isBlack;
                            sibling->isBlack = parent->isBlack;
                            rightRotate(parent);
                        }
                        else
                        {
                            // right left
                            sibling->left->isBlack = parent->isBlack;
                            rightRotate(sibling);
                            leftRotate(parent);
                        }
                    }
                    else
                    {
                        if (sibling == sibling->parent->left)
                        {
                            // left right
                            sibling->right->isBlack = parent->isBlack;
                            leftRotate(sibling);
                            rightRotate(parent);
                        }
                        else
                        {
                            // right right
                            sibling->right->isBlack = sibling->isBlack;
                            sibling->isBlack = parent->isBlack;
                            leftRotate(parent);
                        }
                    }
                    parent->isBlack = true;
                }
                else
                {
                    // 2 black children
                    sibling->isBlack = false;
                    if (parent->isBlack == true)
                        fixDoubleBlack(parent);
                    else
                        parent->isBlack = true;
                }
            }
        }
    }

    // prints level order for given NodeT

    // prints inorder recursively
    void inorder(NodeT<X> *x)
    {
        if (x == NULL)
            return;
        inorder(x->left);
        //cout << x->data << " ";
        inorder(x->right);
    }



    void removeAll();
    void copyitems(const RedBlackTree<X> & rbt);

    // PRE: original and copy are appropriate pointers
    // PARAM: original = pointer to a NodeT in a RedBlackTree being copied
    //        copy = pointer to a NodeT in the calling object
    // POST: calling object is made a copy of dq
    //void copyNodeT(NodeT* original, NodeT* copy);

    // Deallocates all dynamic memory associated with calling object


};



template<class X>
RedBlackTree<X> & RedBlackTree<X>::operator=(const RedBlackTree<X> &rbt)
{
    if(this == &rbt)
        return *this;
    removeAll();
    //cout<< "removed"<<endl;
    copyhelper(this->root, nullptr, rbt.root);
    //tem = front;
    //cout<< "copied"<<endl;
    this->n = rbt.n;
    return *this;

}

template<class X>
void RedBlackTree<X>::removeAll()
{
   helperremove(root);
   root = nullptr;
   n=0;
}



template<class X>
RedBlackTree<X>::~RedBlackTree()
{
    //cout << "... in destructor ..."; // debug print
    //removeAll();
    root=nullptr;
    n=0;
}


template<class X>
bool RedBlackTree<X>::search(X val) const
{
    // RedBlackTree is empty
    NodeT<X> *temp = root;
    while (temp != NULL) {
      if (val < temp->data) {
        if (temp->left == NULL)
          break;
        else
          temp = temp->left;
      } else if (val == temp->data) {
        return true;
      } else {
        if (temp->right == NULL)
          break;
        else
          temp = temp->right;
      }
    }

    return false;
}

template<class X>
bool RedBlackTree<X>::insert(X n)
{
    // RedBlackTree is empty
   NodeT<X> *newNode = new NodeT<X>(n);
    if (root == NULL) {
      // when root is null
      // simply insert value at root
      newNode->isBlack = true;
      root = newNode;
    } else {
      NodeT<X> *temp = searchNode(n);

      if (temp->data == n) {
        // return if value already exists
        return false;
      }

      // if value is not found, search returns the node
      // where the value is to be inserted

      // connect new node to correct node
      newNode->parent = temp;

      if (n < temp->data)
        temp->left = newNode;
      else
        temp->right = newNode;

      // fix red red voilaton if exists
      fixRedRed(newNode);
    }
    this->n++;
    return true;
}

template<class X>
bool RedBlackTree<X>:: remove(X n)
{
    if (root == NULL)
      // Tree is empty
      return false;

    NodeT<X> *v= searchNode(n);

    if (v->data!=n) {
      return false;
    }

    deleteNode(v);
    this->n--;
    return true;
}

template<class X>
vector<X> RedBlackTree<X>:: search(X low, X high) const{
    vector<X> to_return;
    if(root==NULL)
        return to_return;
    X tem = min(low, high);
    X tem2 = max(low, high);
    low = tem;
    high = tem2;
    for(X x=low; x<=high; x++){
        if(search(x)){
            to_return.push_back(x);
        }
    }
    return to_return;
}

template<class X>
vector<X> RedBlackTree<X>:: values(){
    vector<X> to_return;
    if(root==NULL)
        return to_return;
    NodeT<X> *tem;
    tem=root;
    helper(tem, to_return);
    sort(to_return.begin(), to_return.end());
    return to_return;
}

template<class X>
int RedBlackTree<X>:: size() const
{

    return n;
}

template<class X>
X RedBlackTree<X>:: closestLess(X x)
{
    NodeT<X> *tem = root;
    X val = x;
    helperofclosestless(root, x, val);
    return val;
}


template<class X>
X RedBlackTree<X>:: closestGreater(X x)
{
    NodeT<X> *tem = root;
    X val = x;
    helperofclosestgreater(root, x, val);
    return val;
}

template<class X>
void RedBlackTree<X>:: copyitems(const RedBlackTree<X> &rbt)
{
    //cout<< "in: "<< rbt.size()<<endl;
    if(rbt.size()==0) return;
    //NodeT<X> *rootOfRbt = rbt.root;
    copyhelper(root, nullptr, rbt.root);


}

void statistics(string filename)
{
    char name[1000];
    for(int i=0;i<filename.size();i++){
        name[i]=filename[i];
    }
    FILE* fp = fopen(name, "r");
    RedBlackTree<double> rbt;
    double tem;
    while(fscanf(fp, "%lf", &tem)!=EOF){
        //cout<<tem<<endl;
        rbt.insert(tem);
    }
    cout<< "# of values: "<< rbt.size()<<endl;
    vector<double> v = rbt.values();
    double sum = 0;
    for(auto a: v){
        sum+=a;
    }
    double average = sum/(double)rbt.size();
    cout<< "average:     "<<average<<endl;
    if(v.size()%2)
        cout<< "median:      "<<v[v.size()/2]<<endl;
    else
        cout<< "median:      "<<(v[v.size()/2-1]+v[v.size()/2])/2<<endl;
    cout<< "closest < 42: "<<rbt.closestLess(42)<<endl;
    cout<< "closest > 42: "<<rbt.closestGreater(42)<<endl;
}
